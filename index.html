<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Character</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", "SF Pro Display", -apple-system,
          BlinkMacSystemFont, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        color: #ffffff;
      }

      /* 静的な背景 */
      body::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(255, 255, 255, 0.15) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(255, 255, 255, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 60%,
            rgba(255, 255, 255, 0.08) 0%,
            transparent 50%
          );
      }

      .character-container {
        position: relative;
        z-index: 1;
        text-align: center;
        padding: 40px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(20px);
        border-radius: 32px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 32px 64px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .character {
        width: 280px;
        height: 280px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.3),
          0 8px 16px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .character-glow {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 320px;
        height: 320px;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.15) 0%,
          rgba(255, 255, 255, 0.05) 50%,
          transparent 70%
        );
        pointer-events: none;
        opacity: 0.8;
      }

      .character {
        cursor: pointer;
      }

      /* 録音状態のスタイル */
      .character.recording {
        border-color: #ff4757;
        box-shadow: 0 24px 48px rgba(255, 71, 87, 0.4),
          0 8px 16px rgba(255, 71, 87, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      /* 録音インジケーター */
      .recording-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 12px;
        height: 12px;
        background: #ff4757;
        border-radius: 50%;
        opacity: 0;
        transform: scale(0);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .recording-indicator.active {
        opacity: 1;
        transform: scale(1);
      }

      /* 録音中の背景変化 */
      .character-container.recording {
        background: rgba(255, 71, 87, 0.1);
        border-color: rgba(255, 71, 87, 0.3);
        box-shadow: 0 32px 64px rgba(255, 71, 87, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .result-panel {
        position: absolute;
        bottom: 24px;
        left: 24px;
        right: 24px;
        max-height: 40vh;
        padding: 16px;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.15);
        overflow: auto;
      }

      .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-weight: 600;
        opacity: 0.9;
      }

      .result-actions button {
        appearance: none;
        border: 0;
        padding: 6px 10px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
        cursor: pointer;
      }

      .result-text {
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 14px;
        opacity: 0.95;
      }
    </style>
  </head>
  <body>
    <div class="character-container" id="characterContainer">
      <div class="character-glow"></div>
      <div class="recording-indicator" id="recordingIndicator"></div>
      <img
        src="girl.png"
        alt="キャラクター"
        class="character"
        id="characterImage"
      />
    </div>

    <div class="result-panel" id="resultPanel" style="display: none;">
      <div class="result-header">
        <span id="resultTitle">結果</span>
        <div class="result-actions">
          <button id="copyBtn">コピー</button>
        </div>
      </div>
      <div class="result-text" id="resultText"></div>
    </div>

    <script>
      const characterImage = document.getElementById("characterImage");
      const characterContainer = document.getElementById("characterContainer");
      const recordingIndicator = document.getElementById("recordingIndicator");
      const resultPanel = document.getElementById("resultPanel");
      const resultTextEl = document.getElementById("resultText");
      const resultTitleEl = document.getElementById("resultTitle");
      const copyBtn = document.getElementById("copyBtn");

      let currentImageIndex = 0;
      let isRecording = false;
      const images = ["girl.png", "girl2.png"];

      // MediaRecorder state
      let mediaStream = null;
      let mediaRecorder = null;
      let ipcRenderer = null;
      if (typeof require !== "undefined") {
        ({ ipcRenderer } = require("electron"));
      }

      // シングルクリックで画像切り替えと録音切り替え
      characterImage.addEventListener("click", () => {
        // 画像切り替え
        currentImageIndex = (currentImageIndex + 1) % images.length;
        characterImage.src = images[currentImageIndex];

        // 録音状態の切り替え
        toggleRecording();
      });

      // キーボードショートカット（Ctrl+Space）
      document.addEventListener("keydown", (event) => {
        if (event.ctrlKey && event.code === "Space") {
          event.preventDefault();
          toggleRecording();
        }
      });

      // Electronのメインプロセスからのメッセージを受信
      if (ipcRenderer) {
        ipcRenderer.on("toggle-record", () => {
          toggleRecording();
        });
        ipcRenderer.on("recording:result", (_e, payload) => {
          const { text, raw, error, info, filePath } = payload || {};
          let display = "";
          if (error) {
            display = `エラー: ${error}`;
          } else if (text) {
            display = text;
          } else if (raw) {
            display = raw;
          } else if (info) {
            display = info;
          } else {
            display = "結果がありません";
          }
          resultTitleEl.textContent = filePath ? `結果 (${filePath})` : "結果";
          resultTextEl.textContent = display;
          resultPanel.style.display = "block";
        });
      }

      copyBtn?.addEventListener("click", async () => {
        const text = resultTextEl.textContent || "";
        try {
          await navigator.clipboard.writeText(text);
          copyBtn.textContent = "コピー済み";
          setTimeout(() => (copyBtn.textContent = "コピー"), 1200);
        } catch (_) {}
      });

      async function ensureStream() {
        if (mediaStream) return;
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } catch (err) {
          alert("マイクへのアクセスに失敗しました: " + err);
          throw err;
        }
      }

      async function startRecording() {
        await ensureStream();
        const mimeType = "audio/webm;codecs=opus";
        if (!window.MediaRecorder || !MediaRecorder.isTypeSupported?.(mimeType)) {
          alert("この環境では録音がサポートされていません");
          return;
        }

        mediaRecorder = new MediaRecorder(mediaStream, { mimeType });

        if (ipcRenderer) await ipcRenderer.invoke("recording:start", { mimeType });

        mediaRecorder.addEventListener("dataavailable", async (e) => {
          if (!e.data || e.data.size === 0) return;
          const arrayBuffer = await e.data.arrayBuffer();
          const nodeBuffer = Buffer.from(arrayBuffer);
          ipcRenderer?.send("recording:data", nodeBuffer);
        });
        mediaRecorder.addEventListener("stop", () => {
          ipcRenderer?.invoke("recording:stop");
        });

        mediaRecorder.start(250);
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }
      }

      async function toggleRecording() {
        isRecording = !isRecording;

        if (isRecording) {
          characterImage.classList.add("recording");
          characterContainer.classList.add("recording");
          recordingIndicator.classList.add("active");
          resultPanel.style.display = "none";
          await startRecording();
        } else {
          characterImage.classList.remove("recording");
          characterContainer.classList.remove("recording");
          recordingIndicator.classList.remove("active");
          stopRecording();
        }
      }
    </script>
  </body>
</html>
